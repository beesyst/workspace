name: Auto Cheatsheets TOC

on:
  push:
    branches: [ main ]
    paths:
      - 'cheatsheets/**/*.md'
      - 'README.md'
      - '.github/workflows/toc.yml'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-toc:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      # 1) В каждом cheatsheet гарантируем плейсхолдеры <!-- START doctoc --> <!-- END doctoc --> сразу после первого H1
      - name: Ensure doctoc placeholders exist after first H1
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t FILES < <(find cheatsheets -type f -name '*.md' | sort)
          for FILE in "${FILES[@]}"; do
            if ! grep -q "<!-- START doctoc" "$FILE"; then
              awk '
                BEGIN{placed=0}
                placed==0 && /^# / {
                  print
                  print ""
                  print "<!-- START doctoc -->"
                  print "<!-- END doctoc -->"
                  print ""
                  placed=1
                  next
                }
                { print }
              ' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
            fi
          done

      # 2) Генерим TOC внутри самих шпаргалок
      - name: Generate TOC inside cheatsheets
        run: npx -y doctoc cheatsheets --github --maxlevel 3 --title "## Оглавление"

      # 3) Собираем сворачиваемые списки в README (строго в один блок между START/END под заголовком "Шпаргалки")
      - name: Inject cheatsheets TOC into README (collapsible, anchored)
        shell: bash
        run: |
          set -euo pipefail
          README="README.md"
          TOC_START="<!-- START:cheatsheets-toc -->"
          TOC_END="<!-- END:cheatsheets-toc -->"
          ANCHOR='### Шпаргалки (`cheatsheets/`)'

          # --- Сформировать контент из doctoc каждого файла
          TMP="README.new"; : > "$TMP"
          mapfile -t FILES < <(find cheatsheets -type f -name '*.md' | sort)
          for FILE in "${FILES[@]}"; do
            REL="$FILE"
            TITLE="$(grep -m1 -E '^# ' "$FILE" | sed 's/^# \+//; s/\r$//')"
            [[ -z "$TITLE" ]] && TITLE="$(basename "$FILE" .md | sed 's/-/ /g; s/\b\(.\)/\u\1/g')"

            TOC_CONTENT="$(awk '/<!-- START doctoc/{f=1;next} /<!-- END doctoc/{f=0} f' "$FILE" \
              | sed -E '1{/^##[[:space:]]+(Оглавление|Table of Contents)$/Id;}' \
              | sed "s|](#|]($REL#|g")"

            {
              echo "<details>"
              printf '  <summary><strong><a href="%s">%s</a></strong></summary>\n\n' "$REL" "$TITLE"
              printf '%s\n\n' "$TOC_CONTENT"
              echo "</details>"
              echo
            } >> "$TMP"
          done

          # --- Снести любые старые/кривые блоки START/END целиком
          awk -v s="$TOC_START" -v e="$TOC_END" '
            $0==s {in=1; next}
            $0==e {in=0; next}
            !in    {print}
          ' "$README" > README.clean

          # --- Убедиться, что под заголовком ANCHOR стоит пустой блок START/END (если нет — вставим)
          awk -v anchor="$ANCHOR" -v s="$TOC_START" -v e="$TOC_END" '
            $0==anchor && !done {
              print
              print ""
              print s
              print ""
              print e
              print ""
              done=1
              next
            }
            { print }
          ' README.clean > README.norm

          # --- Заполнить этот блок сгенерированным контентом
          awk -v s="$TOC_START" -v e="$TOC_END" '
            $0==s { print; system("cat README.new"); next }
            { print }
          ' README.norm > "$README"

      # 4) Коммитим только если были изменения
      - uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs(toc): auto update cheatsheets TOC"
          file_pattern: |
            cheatsheets/**/*.md
            README.md
